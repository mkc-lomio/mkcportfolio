import { Category, H, C, Code, Ul, Li, P, Tip } from "./shared";

export const csharp: Category = {
  id: "csharp", title: "C#", icon: "⚙️", topics: [
  { id: "class", title: "Classes & Objects", tags: ["class", "OOP"], difficulty: "basic",
    summary: "Class = blueprint. Object = instance.",
    content: (<><P>A <H>class</H> defines properties and methods. An <H>object</H> is an instance.</P></>) },
  { id: "abstract-class", title: "Abstract Class", tags: ["abstract", "OOP", "inheritance"], difficulty: "intermediate",
    summary: "Cannot be instantiated. Has both abstract and concrete methods.",
    content: (<><P>Cannot be instantiated, meant to be inherited. Can have abstract (no body) and implemented methods.</P><Tip>"Abstract class = shared base logic + forced subclass implementation."</Tip></>) },
  { id: "interface-vs-abstract", title: "Interface vs Abstract Class", tags: ["interface", "abstract"], difficulty: "intermediate",
    summary: "Abstract = functionality + contract. Interface = contract only. Multiple interfaces OK.",
    content: (<><P><H>Abstract</H> — functionality that subclasses implement or override.</P><P><H>Interface</H> — only define functionality (contract).</P><P>A class can implement <H>multiple interfaces</H> but inherit only <H>one</H> class.</P></>) },
  { id: "virtual-override", title: "virtual vs override", tags: ["virtual", "override", "polymorphism"], difficulty: "basic",
    summary: "virtual allows overriding. override provides new implementation.",
    content: (<><P><C>virtual</C> allows overriding. <C>override</C> provides new implementation in derived class.</P></>) },
  { id: "ref-out", title: "ref vs out", tags: ["ref", "out", "parameters"], difficulty: "basic",
    summary: "ref = must init before. out = must assign inside method.",
    content: (<><Ul><Li><C>ref</C> — must be initialized before passing</Li><Li><C>out</C> — must be assigned inside the method</Li></Ul></>) },
  { id: "value-ref-types", title: "Value Types vs Reference Types", tags: ["value types", "reference types", "memory"], difficulty: "basic",
    summary: "Value = data on stack. Reference = pointer on heap.",
    content: (<><Ul><Li><H>Value</H> — <C>int</C>, <C>float</C>, <C>bool</C>, <C>struct</C>, <C>enum</C> → stack</Li><Li><H>Reference</H> — <C>class</C>, <C>interface</C>, <C>array</C>, <C>string</C> → heap</Li></Ul></>) },
  { id: "boxing", title: "Boxing & Unboxing", tags: ["boxing", "memory"], difficulty: "basic",
    summary: "Boxing = value→object (heap). Unboxing = object→value (stack).",
    content: (<><P><H>Boxing</H> = value → object. <H>Unboxing</H> = object → value. Avoid excessive boxing (perf hit).</P></>) },
  { id: "const-readonly", title: "const vs readonly vs enum", tags: ["constants", "readonly", "enum"], difficulty: "basic",
    summary: "const = compile-time. readonly = runtime (constructor). enum = named constants.",
    content: (<><Ul><Li><C>const</C> — compile-time, assigned at declaration</Li><Li><C>readonly</C> — runtime, assigned in constructor</Li><Li><C>enum</C> — named integer constants</Li></Ul></>) },
  { id: "async-await", title: "Async/Await", tags: ["async", "await", "threading"], difficulty: "intermediate",
    summary: "Async = concurrent (non-blocking). Sync = sequential (blocking).",
    content: (<><P><H>Async</H> — non-blocking. <H>Sync</H> — one after another.</P><Tip>"I use async/await for I/O operations like DB calls and HTTP requests to avoid blocking threads."</Tip></>) },
  { id: "lock-keyword", title: "lock Keyword", tags: ["lock", "threading"], difficulty: "intermediate",
    summary: "Only one thread accesses a code block at a time.",
    content: (<><P><C>lock</C> ensures only <H>one thread</H> at a time. Prevents race conditions.</P></>) },
  { id: "deadlock", title: "Deadlock", tags: ["deadlock", "threading"], difficulty: "advanced",
    summary: "Two+ threads waiting for each other forever.",
    content: (<><P>Threads <H>waiting for each other</H> — neither proceeds.</P><P><H>Prevent:</H> Lock ordering, timeouts, avoid nested locks.</P></>) },
  { id: "thread-task", title: "Thread vs Task", tags: ["thread", "task", "parallelism"], difficulty: "intermediate",
    summary: "Thread = low-level. Task = high-level using ThreadPool.",
    content: (<><Ul><Li><H>Thread</H> — low-level, manual</Li><Li><H>Task</H> — high-level, uses ThreadPool</Li><Li><H>ThreadPool</H> — managed reusable threads</Li></Ul></>) },
  { id: "delegates-events", title: "Delegates & Events", tags: ["delegates", "events"], difficulty: "intermediate",
    summary: "Delegate = function pointer. Event = notification. Handler = method that runs.",
    content: (<><Ul><Li><H>Delegate</H> — type-safe function pointer</Li><Li><H>Event</H> — notifies subscribers</Li><Li><H>Handler</H> — method that runs on event</Li></Ul></>) },
  { id: "generics", title: "Generics", tags: ["generics", "type safety"], difficulty: "intermediate",
    summary: "Code that works with any type without specifying it upfront.",
    content: (<><Code>{`public class Repository<T> where T : class
{
    public T GetById(int id) { ... }
    public void Add(T entity) { ... }
}`}</Code></>) },
  { id: "access-modifiers", title: "Access Modifiers", tags: ["access modifiers", "encapsulation"], difficulty: "basic",
    summary: "public, private, protected, internal, protected internal, private protected.",
    content: (<><Ul><Li><C>public</C> — anywhere</Li><Li><C>private</C> — class only</Li><Li><C>protected</C> — class + subclasses</Li><Li><C>internal</C> — same assembly</Li><Li><C>protected internal</C> — assembly OR subclasses</Li><Li><C>private protected</C> — subclasses in same assembly</Li></Ul></>) },
  { id: "exception-handling", title: "Exception Handling", tags: ["exceptions", "try-catch"], difficulty: "basic",
    summary: "try/catch/finally/throw for controlled runtime error handling.",
    content: (<><P>Uses <C>try</C>, <C>catch</C>, <C>finally</C>, <C>throw</C> for runtime error handling.</P></>) },
  { id: "string-builder", title: "String vs StringBuilder", tags: ["string", "performance"], difficulty: "basic",
    summary: "String = immutable (new object each change). StringBuilder = mutable (same object).",
    content: (<><Ul><Li><H>String</H> — immutable, new object each change</Li><Li><H>StringBuilder</H> — mutable, same object</Li></Ul><P>Use <C>StringBuilder</C> for loops/heavy string manipulation.</P></>) },
  { id: "casting", title: "Implicit vs Explicit Casting", tags: ["casting", "types"], difficulty: "basic",
    summary: "Implicit = auto (small→large). Explicit = manual (large→small).",
    content: (<><P><H>Implicit:</H> <C>char → int → long → float → double</C></P><P><H>Explicit:</H> <C>double → float → long → int → char</C></P></>) },
  { id: "tuple", title: "Tuple", tags: ["tuple", "data structure"], difficulty: "basic",
    summary: "Fixed elements of different types. Quick multi-value returns.",
    content: (<><Code>{`var person = ("Alice", 30);
Console.WriteLine(person.Item1); // Alice`}</Code><P>For complex objects, prefer a class.</P></>) },
  { id: "namespace", title: "Namespace", tags: ["namespace", "organization"], difficulty: "basic",
    summary: "Organizes code and avoids name conflicts.",
    content: (<><P>Helps <H>organize code</H> and avoid name conflicts.</P></>) },
]};
