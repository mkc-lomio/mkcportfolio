import { Category, H, C, Code, Ul, Li, Ol, Ni, P, Tip } from "./shared";

export const sql: Category = {
  id: "sql", title: "SQL", icon: "üóÑÔ∏è", topics: [
  { id: "tsql", title: "Transact-SQL (T-SQL)", tags: ["T-SQL", "SQL Server", "fundamentals"], difficulty: "basic",
    summary: "SQL Server's extension with control flow, variables, error handling, transactions.",
    content: (<><Ul><Li><H>Control Flow</H> ‚Äî <C>IF</C>, <C>WHILE</C>, <C>CASE</C></Li><Li><H>Variables</H> ‚Äî <C>DECLARE @name NVARCHAR(50)</C></Li><Li><H>Error Handling</H> ‚Äî <C>TRY...CATCH</C></Li><Li><H>Transactions</H> ‚Äî <C>BEGIN TRAN</C>, <C>COMMIT</C>, <C>ROLLBACK</C></Li></Ul></>) },
  { id: "select-clauses", title: "6 Principal Clauses of SELECT", tags: ["SELECT", "syntax"], difficulty: "basic",
    summary: "SELECT ‚Üí FROM ‚Üí WHERE ‚Üí GROUP BY ‚Üí HAVING ‚Üí ORDER BY",
    content: (<><Ol><Ni n={1}><C>SELECT</C> ‚Äî columns</Ni><Ni n={2}><C>FROM</C> ‚Äî tables</Ni><Ni n={3}><C>WHERE</C> ‚Äî filter rows</Ni><Ni n={4}><C>GROUP BY</C> ‚Äî group</Ni><Ni n={5}><C>HAVING</C> ‚Äî filter groups</Ni><Ni n={6}><C>ORDER BY</C> ‚Äî sort</Ni></Ol></>) },
  { id: "acid", title: "ACID Principle", tags: ["ACID", "transactions"], difficulty: "basic",
    summary: "Atomicity, Consistency, Isolation, Durability ‚Äî reliable transactions.",
    content: (<><Ul><Li><H>Atomicity</H> ‚Äî All or nothing</Li><Li><H>Consistency</H> ‚Äî Data stays valid</Li><Li><H>Isolation</H> ‚Äî No interference</Li><Li><H>Durability</H> ‚Äî Committed = permanent</Li></Ul><Tip>Bank transfer: "Either both accounts update or neither does."</Tip></>) },
  { id: "nvarchar-varchar", title: "NVARCHAR vs VARCHAR", tags: ["data types", "unicode"], difficulty: "basic",
    summary: "VARCHAR = ASCII (1 byte). NVARCHAR = Unicode (2 bytes, multi-language).",
    content: (<><P><H>VARCHAR</H> ‚Äî ASCII, 1 byte. <H>NVARCHAR</H> ‚Äî Unicode, 2 bytes.</P><P>Use <C>NVARCHAR</C> for multi-language data.</P></>) },
  { id: "like-operator", title: "LIKE Operator & Wildcards", tags: ["LIKE", "wildcard", "filtering"], difficulty: "basic",
    summary: "'Marc%' starts with. '%Marc' ends with. '%Marc%' contains.",
    content: (<><Ul><Li><C>'Marc%'</C> ‚Äî Starts with</Li><Li><C>'%Marc'</C> ‚Äî Ends with</Li><Li><C>'%Marc%'</C> ‚Äî Contains</Li></Ul><P>Only prefix patterns are SARGable.</P></>) },
  { id: "where-having", title: "WHERE vs HAVING", tags: ["WHERE", "HAVING", "filtering"], difficulty: "basic",
    summary: "WHERE filters rows before grouping. HAVING filters groups after aggregation.",
    content: (<><Ul><Li><H>WHERE</H> ‚Äî before grouping</Li><Li><H>HAVING</H> ‚Äî after aggregation</Li></Ul><Code>{`SELECT Dept, COUNT(*) AS Total FROM Employees
WHERE IsActive = 1 GROUP BY Dept HAVING COUNT(*) > 5;`}</Code></>) },
  { id: "aggregation", title: "Aggregate Functions", tags: ["aggregation", "functions"], difficulty: "basic",
    summary: "SUM, COUNT, AVG, MIN, MAX ‚Äî calculate over groups.",
    content: (<><P><C>SUM()</C>, <C>COUNT()</C>, <C>AVG()</C>, <C>MIN()</C>, <C>MAX()</C></P><P>Used with <C>GROUP BY</C> for per-group results.</P></>) },
  { id: "group-by", title: "GROUP BY", tags: ["GROUP BY", "grouping"], difficulty: "basic",
    summary: "Groups rows by column. SELECT columns must be grouped or aggregated.",
    content: (<><Code>{`SELECT Dept, COUNT(*) FROM Employees GROUP BY Dept;`}</Code><P>Every <C>SELECT</C> column must be in <C>GROUP BY</C> or an aggregate.</P></>) },
  { id: "distinct", title: "DISTINCT", tags: ["DISTINCT", "duplicates"], difficulty: "basic",
    summary: "Eliminates duplicate rows from result set.",
    content: (<><Code>{`SELECT DISTINCT Department FROM Employees;`}</Code></>) },
  { id: "outer-apply", title: "OUTER APPLY", tags: ["APPLY", "joins", "subqueries"], difficulty: "advanced",
    summary: "Like LEFT JOIN but for correlated subqueries and TVFs.",
    content: (<><Ul><Li>Right side can reference left-side columns</Li><Li><C>CROSS APPLY</C> = INNER JOIN equivalent</Li></Ul><Tip>"I use APPLY when joining a TVF or correlated subquery that depends on each left-table row."</Tip></>) },
  { id: "clustered-idx", title: "Clustered Index", tags: ["indexing", "clustered", "performance"], difficulty: "intermediate",
    summary: "Physical order of rows. One per table. Usually the primary key.",
    content: (<><Ul><Li>Only <H>one</H> per table (usually PK)</Li><Li>Leaf nodes = actual data rows</Li><Li>Ideal for range queries, <C>ORDER BY</C></Li></Ul></>) },
  { id: "nonclustered-idx", title: "Non-Clustered Index", tags: ["indexing", "non-clustered", "performance"], difficulty: "intermediate",
    summary: "Separate structure with pointers. Multiple per table. Use INCLUDE.",
    content: (<><Ul><Li>Multiple per table (up to 999)</Li><Li>Adds write overhead</Li><Li>Use <C>INCLUDE</C> for covering indexes</Li></Ul></>) },
  { id: "sargable", title: "SARGable Queries", tags: ["SARGable", "performance", "indexing"], difficulty: "intermediate",
    summary: "Conditions that allow index seeks. Avoid functions on columns in WHERE.",
    content: (<><P><H>‚úÖ Good:</H> <C>=</C>, <C>IN</C>, <C>BETWEEN</C>, <C>LIKE 'prefix%'</C></P><P><H>‚ùå Bad:</H> Functions on columns, calculations, leading wildcards</P><Ul><Li>‚ùå <C>WHERE YEAR(HireDate) = 2023</C></Li><Li>‚úÖ <C>{"WHERE HireDate >= '2023-01-01' AND HireDate < '2024-01-01'"}</C></Li></Ul></>) },
  { id: "execution-plan", title: "Execution Plans", tags: ["execution plan", "optimization"], difficulty: "intermediate",
    summary: "Shows DB engine steps. Red flags: scans, key lookups, thick arrows.",
    content: (<><Ol><Ni n={1}><H>Estimated</H> ‚Äî without running</Ni><Ni n={2}><H>Actual</H> ‚Äî after running</Ni><Ni n={3}><H>Live Statistics</H> ‚Äî real-time in SSMS</Ni></Ol><P><H>Red flags:</H> Table Scans, Key Lookups, thick arrows, high-cost Sort/Hash Match.</P></>) },
  { id: "query-opt", title: "Query Optimization Checklist", tags: ["optimization", "performance"], difficulty: "intermediate",
    summary: "Index properly, no SELECT *, EXISTS over IN, analyze execution plans.",
    content: (<><Ol><Ni n={1}>Index on WHERE/JOIN/ORDER BY columns</Ni><Ni n={2}>No <C>SELECT *</C></Ni><Ni n={3}>SARGable WHERE</Ni><Ni n={4}>Prefer <C>INNER JOIN</C></Ni><Ni n={5}><C>EXISTS</C> over <C>IN</C></Ni><Ni n={6}>Analyze Execution Plans</Ni><Ni n={7}>Update Statistics</Ni><Ni n={8}>Avoid Cursors</Ni></Ol></>) },
  { id: "cursor", title: "CURSORs", tags: ["cursor", "anti-pattern"], difficulty: "intermediate",
    summary: "Row-by-row. Slow. Use set-based operations instead.",
    content: (<><P>Row-by-row processing. <H>Slow</H>, holds locks longer.</P><P>‚úÖ Use <C>UPDATE</C>, <C>JOIN</C>, <C>MERGE</C> instead.</P></>) },
  { id: "normalization", title: "Normalization & Denormalization", tags: ["normalization", "database design"], difficulty: "basic",
    summary: "Normalize for writes (less redundancy). Denormalize for reads (faster queries).",
    content: (<><P><H>Normalization</H> ‚Äî split tables, FK, less redundancy.</P><P><H>Denormalization</H> ‚Äî merge tables, faster reads.</P><Tip>"Normalize for writes, denormalize for reads."</Tip></>) },
  { id: "triggers", title: "Database Triggers", tags: ["triggers", "automation"], difficulty: "intermediate",
    summary: "Auto-run on INSERT/UPDATE/DELETE. Use sparingly.",
    content: (<><P>Runs on <C>INSERT</C>, <C>UPDATE</C>, <C>DELETE</C>.</P><P><H>Use:</H> Audit logs, business rules. <H>Caution:</H> Silent side effects.</P></>) },
  { id: "conn-pool", title: "Connection Pooling", tags: ["connection pooling", "ADO.NET"], difficulty: "basic",
    summary: "Reuses DB connections. Close() returns to pool. Default in .NET.",
    content: (<><Ol><Ni n={1}>Pool created on first request</Ni><Ni n={2}>Subsequent requests reuse</Ni><Ni n={3}>Close()/Dispose() returns to pool</Ni></Ol><P>Default in ADO.NET and EF Core.</P></>) },
  { id: "views", title: "Regular vs Materialized Views", tags: ["views", "materialized views"], difficulty: "intermediate",
    summary: "Regular = virtual, real-time. Materialized = stored, precomputed.",
    content: (<><P><H>Regular</H> ‚Äî virtual, always fresh, can be slow.</P><P><H>Materialized</H> ‚Äî stored on disk, fast, can be stale.</P><Tip>"Regular for real-time, materialized for dashboards and reporting."</Tip></>) },
]};
