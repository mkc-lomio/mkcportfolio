import { Category, H, C, Code, Ul, Li, Ol, Ni, P, Tip } from "./shared";

export const principles: Category = {
  id: "principles", title: "Principles & Architecture", icon: "üìê", topics: [
  { id: "oop", title: "OOP", tags: ["OOP", "fundamentals"], difficulty: "basic",
    summary: "Organize code using objects. Four pillars.",
    content: (<><P>OOP organizes code using <H>objects</H> ‚Äî instances of classes.</P></>) },
  { id: "encapsulation", title: "Encapsulation", tags: ["OOP", "encapsulation"], difficulty: "basic",
    summary: "Hide internals, expose only what's necessary. Access modifiers.",
    content: (<><P><H>Hide + Protect + Organize.</H></P><Ul><Li>‚úÖ Data protection</Li><Li>‚úÖ Controlled access via getters/setters</Li><Li>‚úÖ Reusability and modularity</Li></Ul></>) },
  { id: "abstraction", title: "Abstraction", tags: ["OOP", "abstraction"], difficulty: "basic",
    summary: "What an object does, not how. Abstract classes + interfaces.",
    content: (<><Ul><Li>Abstract Classes ‚Äî partial abstraction</Li><Li>Interfaces ‚Äî full abstraction</Li></Ul><Tip>"Like a remote control ‚Äî press Power, don't need to know how the signal works."</Tip></>) },
  { id: "inheritance-oop", title: "Inheritance", tags: ["OOP", "inheritance"], difficulty: "basic",
    summary: "Child inherits from parent. Reuse, hierarchy, maintainability.",
    content: (<><Ul><Li>‚úÖ Code reuse</Li><Li>‚úÖ Logical hierarchy</Li><Li>‚úÖ Change parent ‚Üí affects children</Li></Ul></>) },
  { id: "polymorphism", title: "Polymorphism", tags: ["OOP", "polymorphism"], difficulty: "intermediate",
    summary: "Many forms. Overloading (compile-time) + Overriding (runtime).",
    content: (<><Ul><Li><H>Compile-time</H> ‚Äî Method Overloading (same name, different params)</Li><Li><H>Runtime</H> ‚Äî Method Overriding (<C>override</C> in child class)</Li></Ul></>) },
  { id: "solid", title: "SOLID Principles", tags: ["SOLID", "architecture"], difficulty: "intermediate",
    summary: "SRP, OCP, LSP, ISP, DIP ‚Äî maintainable OOP design.",
    content: (<><Ol><Ni n={1}><H>S</H> ‚Äî Single Responsibility. One reason to change.</Ni><Ni n={2}><H>O</H> ‚Äî Open/Closed. Extend, don't modify.</Ni><Ni n={3}><H>L</H> ‚Äî Liskov Substitution. Subclass = swappable.</Ni><Ni n={4}><H>I</H> ‚Äî Interface Segregation. Small, specific interfaces.</Ni><Ni n={5}><H>D</H> ‚Äî Dependency Inversion. Depend on abstractions.</Ni></Ol><Tip>Example for D: "PaymentService depends on IPaymentGateway, not Stripe or PayPal."</Tip></>) },
  { id: "patterns-overview", title: "Design Patterns Overview", tags: ["design patterns", "GoF"], difficulty: "basic",
    summary: "Creational (how created), Behavioral (how communicate), Structural (how structured).",
    content: (<><Ul><Li><H>Creational</H> ‚Äî Singleton, Factory, Builder, Prototype</Li><Li><H>Behavioral</H> ‚Äî Observer, Strategy, Command, Chain of Responsibility</Li><Li><H>Structural</H> ‚Äî Adapter, Decorator, Facade, Proxy</Li></Ul></>) },
  { id: "singleton", title: "Singleton Pattern", tags: ["singleton", "creational"], difficulty: "basic",
    summary: "One instance, global access. Config, logging, cache.",
    content: (<><P>Ensures <H>only one instance</H> with global access.</P><P><H>Uses:</H> Config, Logging, Cache, DB Connection.</P></>) },
  { id: "factory", title: "Factory Method", tags: ["factory", "creational"], difficulty: "intermediate",
    summary: "Subclasses decide which object to create.",
    content: (<><Tip>"Like Uber ‚Äî you request a ride, the factory decides car/bike/scooter."</Tip></>) },
  { id: "observer", title: "Observer Pattern", tags: ["observer", "behavioral"], difficulty: "intermediate",
    summary: "Notifies multiple objects when one changes.",
    content: (<><Tip>"YouTube subscriptions ‚Äî channel uploads, all subscribers notified."</Tip></>) },
  { id: "strategy", title: "Strategy Pattern", tags: ["strategy", "behavioral"], difficulty: "intermediate",
    summary: "Switch behaviors by injecting different strategy objects.",
    content: (<><Tip>"Navigation app ‚Äî same interface, different route strategy (car/bike/walk)."</Tip></>) },
  { id: "adapter", title: "Adapter Pattern", tags: ["adapter", "structural"], difficulty: "intermediate",
    summary: "Makes incompatible interfaces work together.",
    content: (<><P>Converts one interface to another.</P><P><H>Uses:</H> Third-party libs, legacy system integration.</P><Tip>"US power plug in Europe ‚Äî adapter converts interfaces."</Tip></>) },
  { id: "facade", title: "Facade Pattern", tags: ["facade", "structural"], difficulty: "basic",
    summary: "Simplified interface to complex subsystem.",
    content: (<><Tip>"Hotel front desk ‚Äî one point of contact instead of calling each department."</Tip></>) },
  { id: "big-o", title: "Big O Notation", tags: ["Big O", "complexity", "algorithms"], difficulty: "intermediate",
    summary: "O(1) constant < O(log n) binary < O(n) linear < O(n¬≤) nested loops.",
    content: (<><Ul><Li><C>O(1)</C> ‚Äî constant (arr[0])</Li><Li><C>O(log n)</C> ‚Äî binary search</Li><Li><C>O(n)</C> ‚Äî single loop</Li><Li><C>O(n¬≤)</C> ‚Äî nested loops</Li></Ul><Tip>When asked "what's the complexity?" ‚Äî they usually mean worst-case (Big O).</Tip></>) },
  { id: "clean-code", title: "Clean Code", tags: ["clean code", "YAGNI", "KISS", "DRY"], difficulty: "basic",
    summary: "SoC, YAGNI, KISS, DRY ‚Äî write maintainable code.",
    content: (<><Ul><Li><H>Separation of Concerns</H> ‚Äî UI / business / data access</Li><Li><H>YAGNI</H> ‚Äî Don't build what you don't need yet</Li><Li><H>KISS</H> ‚Äî Simple = fewer bugs</Li><Li><H>DRY</H> ‚Äî Reuse via functions</Li></Ul></>) },
  { id: "data-structures", title: "Data Structures Overview", tags: ["data structures", "algorithms"], difficulty: "intermediate",
    summary: "Array, LinkedList, Stack, Queue, Tree, Graph, HashTable, Set.",
    content: (<><P><H>Linear:</H></P><Ul><Li><H>Array</H> ‚Äî fixed size, contiguous memory</Li><Li><H>Linked List</H> ‚Äî nodes with pointers (Singly, Doubly, Circular)</Li><Li><H>Stack</H> ‚Äî LIFO (push/pop)</Li><Li><H>Queue</H> ‚Äî FIFO (enqueue/dequeue)</Li></Ul><P><H>Non-Linear:</H></P><Ul><Li><H>Tree</H> ‚Äî hierarchical (Binary Tree)</Li><Li><H>Graph</H> ‚Äî vertices + edges (Google Maps)</Li></Ul><P><H>Hash-Based:</H> Hash Table (key-value). <H>Set:</H> Unique elements only.</P></>) },
]};
